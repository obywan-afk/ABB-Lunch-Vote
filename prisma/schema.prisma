// prisma/schema.prisma - With Vote History
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Restaurant {
  id          String      @id
  name        String      @unique
  location    String
  description String
  votes       Vote[]
  menuCache   MenuCache[]
  voteHistory VoteHistory[]
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
}

model Vote {
  id           String     @id @default(cuid())
  restaurantId String
  restaurant   Restaurant @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  userId       String
  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  date         String     // YYYY-MM-DD format for the specific voting day
  weekOf       DateTime   // Keep for reporting/history
  createdAt    DateTime   @default(now())
  
  @@unique([userId, date])
  @@index([date])
  @@index([weekOf])
}

model VoteHistory {
  id             String     @id @default(cuid())
  restaurantId   String
  restaurantName String
  userId         String
  userName       String?
  weekOf         DateTime
  originalVoteDate DateTime
  archivedAt     DateTime   @default(now())
  
  restaurant Restaurant @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  
  @@index([weekOf])
  @@index([archivedAt])
}

model User {
  id              String            @id @default(cuid())
  email           String?           @unique
  name            String?
  sessionId       String            @unique
  votes           Vote[]
  lunchNotes      LunchNote[]
  ticTacToePlayers TicTacToePlayer[]
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
}

model LunchNote {
  id         String   @id @default(cuid())
  dateKey    String   @db.VarChar(10)  // YYYY-MM-DD format
  message    String   @db.VarChar(500) // Max 500 chars, enforced at DB level
  authorId   String
  authorName String   @db.VarChar(255) // Display name snapshot at time of posting
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  
  user User @relation(fields: [authorId], references: [id], onDelete: Cascade)
  
  @@index([dateKey, createdAt])
  @@index([authorId])
}

model VotingSession {
  id        String   @id @default(cuid())
  weekOf    DateTime @unique
  isActive  Boolean  @default(true)
  winnerId  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model MenuCache {
  id           String     @id @default(cuid())
  restaurantId String
  language     String     // 'en' or 'fi'
  date         String     // YYYY-MM-DD format
  rawMenu      String
  parsedMenu   String
  parsedMenuJson String? 
  createdAt    DateTime   @default(now())
  scrapedAt    DateTime   @default(now())
  
  restaurant Restaurant @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  
  @@unique([restaurantId, date, language], name: "restaurantId_date_language")
}

model TicTacToeMatch {
  id           String            @id @default(cuid())
  dateKey      String            @db.VarChar(10)
  board        String            @default("---------") // 9 chars, '-' means empty
  currentTurn  String?           @db.VarChar(1)        // 'X' or 'O'
  status       String            @default("waiting")   // waiting | active | finished
  winnerSymbol String?           @db.VarChar(1)
  winnerName   String?
  winningLine  String?
  createdAt    DateTime          @default(now())
  updatedAt    DateTime          @updatedAt
  players      TicTacToePlayer[]
  moves        TicTacToeMove[]

  @@index([dateKey])
}

model TicTacToePlayer {
  id       String   @id @default(cuid())
  matchId  String
  userId   String
  userName String?
  symbol   String   @db.VarChar(1) // 'X' or 'O'
  joinedAt DateTime @default(now())
  match    TicTacToeMatch @relation(fields: [matchId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  moves    TicTacToeMove[]

  @@unique([matchId, symbol])
  @@unique([matchId, userId])
}

model TicTacToeMove {
  id        String   @id @default(cuid())
  matchId   String
  playerId  String
  position  Int
  symbol    String   @db.VarChar(1)
  createdAt DateTime @default(now())
  match     TicTacToeMatch @relation(fields: [matchId], references: [id], onDelete: Cascade)
  player    TicTacToePlayer @relation(fields: [playerId], references: [id], onDelete: Cascade)

  @@unique([matchId, position])
}
